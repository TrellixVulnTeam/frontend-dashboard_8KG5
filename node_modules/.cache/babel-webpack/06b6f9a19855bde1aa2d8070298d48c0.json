{"ast":null,"code":"import _defineProperty from \"c:/Users/ZRANGO/Workspaces/Angular IDE/dashboard/node_modules/@babel/runtime/helpers/esm/defineProperty\";\nimport _toConsumableArray from \"c:/Users/ZRANGO/Workspaces/Angular IDE/dashboard/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _classCallCheck from \"c:/Users/ZRANGO/Workspaces/Angular IDE/dashboard/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"c:/Users/ZRANGO/Workspaces/Angular IDE/dashboard/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _slicedToArray from \"c:/Users/ZRANGO/Workspaces/Angular IDE/dashboard/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport { InjectionToken, Injectable, Inject, Optional, PLATFORM_ID, NgZone, ɵɵdefineInjectable, ɵɵinject, NgModule } from '@angular/core';\nimport { asyncScheduler, Observable, from, of } from 'rxjs';\nimport { startWith, pairwise, map, scan, distinctUntilChanged, filter, observeOn } from 'rxjs/operators';\nimport { ɵAngularFireSchedulers, ɵkeepUnstableUntilFirstFactory, ɵfirebaseAppFactory, ɵlogAuthEmulatorError, ɵfetchInstance, FIREBASE_OPTIONS, FIREBASE_APP_NAME } from '@angular/fire';\nimport { isPlatformServer } from '@angular/common';\nimport firebase from 'firebase/app';\nimport 'firebase/firestore';\nimport { USE_EMULATOR as USE_EMULATOR$1 } from '@angular/fire/auth';\n/**\n * @fileoverview added by tsickle\n * Generated from: observable/fromRef.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @template T, R\n * @param {?} ref\n * @param {?=} scheduler\n * @return {?}\n */\n\nfunction _fromRef(ref) {\n  var scheduler = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : asyncScheduler;\n  return new Observable(\n  /**\n  * @param {?} subscriber\n  * @return {?}\n  */\n  function (subscriber) {\n    /** @type {?} */\n    var unsubscribe;\n\n    if (scheduler != null) {\n      scheduler.schedule(\n      /**\n      * @return {?}\n      */\n      function () {\n        unsubscribe = ref.onSnapshot({\n          includeMetadataChanges: true\n        }, subscriber);\n      });\n    } else {\n      unsubscribe = ref.onSnapshot({\n        includeMetadataChanges: true\n      }, subscriber);\n    }\n\n    return (\n      /**\n      * @return {?}\n      */\n      function () {\n        if (unsubscribe != null) {\n          unsubscribe();\n        }\n      }\n    );\n  });\n}\n/**\n * @template R, T\n * @param {?} ref\n * @param {?=} scheduler\n * @return {?}\n */\n\n\nfunction fromRef(ref, scheduler) {\n  return _fromRef(ref, scheduler);\n}\n/**\n * @template T\n * @param {?} ref\n * @param {?=} scheduler\n * @return {?}\n */\n\n\nfunction fromDocRef(ref, scheduler) {\n  return fromRef(ref, scheduler).pipe(startWith(undefined), pairwise(), map(\n  /**\n  * @param {?} __0\n  * @return {?}\n  */\n  function (_ref) {\n    var _ref2 = _slicedToArray(_ref, 2),\n        priorPayload = _ref2[0],\n        payload = _ref2[1];\n\n    if (!payload.exists) {\n      return {\n        payload: payload,\n        type: 'removed'\n      };\n    }\n\n    if (!(priorPayload === null || priorPayload === void 0 ? void 0 : priorPayload.exists)) {\n      return {\n        payload: payload,\n        type: 'added'\n      };\n    }\n\n    return {\n      payload: payload,\n      type: 'modified'\n    };\n  }));\n}\n/**\n * @template T\n * @param {?} ref\n * @param {?=} scheduler\n * @return {?}\n */\n\n\nfunction fromCollectionRef(ref, scheduler) {\n  return fromRef(ref, scheduler).pipe(map(\n  /**\n  * @param {?} payload\n  * @return {?}\n  */\n  function (payload) {\n    return {\n      payload: payload,\n      type: 'query'\n    };\n  }));\n}\n/**\n * @fileoverview added by tsickle\n * Generated from: collection/changes.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * Return a stream of document changes on a query. These results are not in sort order but in\n * order of occurence.\n * @template T\n * @param {?} query\n * @param {?=} scheduler\n * @return {?}\n */\n\n\nfunction docChanges(query, scheduler) {\n  return fromCollectionRef(query, scheduler).pipe(startWith(undefined), pairwise(), map(\n  /**\n  * @param {?} __0\n  * @return {?}\n  */\n  function (_ref3) {\n    var _ref4 = _slicedToArray(_ref3, 2),\n        priorAction = _ref4[0],\n        action = _ref4[1];\n\n    /** @type {?} */\n    var docChanges = action.payload.docChanges();\n    /** @type {?} */\n\n    var actions = docChanges.map(\n    /**\n    * @param {?} change\n    * @return {?}\n    */\n    function (change) {\n      return {\n        type: change.type,\n        payload: change\n      };\n    }); // the metadata has changed from the prior emission\n\n    if (priorAction && JSON.stringify(priorAction.payload.metadata) !== JSON.stringify(action.payload.metadata)) {\n      // go through all the docs in payload and figure out which ones changed\n      action.payload.docs.forEach(\n      /**\n      * @param {?} currentDoc\n      * @param {?} currentIndex\n      * @return {?}\n      */\n      function (currentDoc, currentIndex) {\n        /** @type {?} */\n        var docChange = docChanges.find(\n        /**\n        * @param {?} d\n        * @return {?}\n        */\n        function (d) {\n          return d.doc.ref.isEqual(currentDoc.ref);\n        });\n        /** @type {?} */\n\n        var priorDoc = priorAction === null || priorAction === void 0 ? void 0 : priorAction.payload.docs.find(\n        /**\n        * @param {?} d\n        * @return {?}\n        */\n        function (d) {\n          return d.ref.isEqual(currentDoc.ref);\n        });\n\n        if (docChange && JSON.stringify(docChange.doc.metadata) === JSON.stringify(currentDoc.metadata) || !docChange && priorDoc && JSON.stringify(priorDoc.metadata) === JSON.stringify(currentDoc.metadata)) {// document doesn't appear to have changed, don't log another action\n        } else {\n          // since the actions are processed in order just push onto the array\n          actions.push({\n            type: 'modified',\n            payload: {\n              oldIndex: currentIndex,\n              newIndex: currentIndex,\n              type: 'modified',\n              doc: currentDoc\n            }\n          });\n        }\n      });\n    }\n\n    return (\n      /** @type {?} */\n      actions\n    );\n  }));\n}\n/**\n * Return a stream of document changes on a query. These results are in sort order.\n * @template T\n * @param {?} query\n * @param {?} events\n * @param {?=} scheduler\n * @return {?}\n */\n\n\nfunction sortedChanges(query, events, scheduler) {\n  return docChanges(query, scheduler).pipe(scan(\n  /**\n  * @param {?} current\n  * @param {?} changes\n  * @return {?}\n  */\n  function (current, changes) {\n    return combineChanges(current, changes.map(\n    /**\n    * @param {?} it\n    * @return {?}\n    */\n    function (it) {\n      return it.payload;\n    }), events);\n  }, []), distinctUntilChanged(), // cut down on unneed change cycles\n  map(\n  /**\n  * @param {?} changes\n  * @return {?}\n  */\n  function (changes) {\n    return changes.map(\n    /**\n    * @param {?} c\n    * @return {?}\n    */\n    function (c) {\n      return (\n        /** @type {?} */\n        {\n          type: c.type,\n          payload: c\n        }\n      );\n    });\n  }));\n}\n/**\n * Combines the total result set from the current set of changes from an incoming set\n * of changes.\n * @template T\n * @param {?} current\n * @param {?} changes\n * @param {?} events\n * @return {?}\n */\n\n\nfunction combineChanges(current, changes, events) {\n  changes.forEach(\n  /**\n  * @param {?} change\n  * @return {?}\n  */\n  function (change) {\n    // skip unwanted change types\n    if (events.indexOf(change.type) > -1) {\n      current = combineChange(current, change);\n    }\n  });\n  return current;\n}\n/**\n * Splice arguments on top of a sliced array, to break top-level ===\n * this is useful for change-detection\n * @template T\n * @param {?} original\n * @param {?} start\n * @param {?} deleteCount\n * @param {...?} args\n * @return {?}\n */\n\n\nfunction sliceAndSplice(original, start, deleteCount) {\n  /** @type {?} */\n  var returnArray = original.slice();\n\n  for (var _len = arguments.length, args = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {\n    args[_key - 3] = arguments[_key];\n  }\n\n  returnArray.splice.apply(returnArray, [start, deleteCount].concat(args));\n  return returnArray;\n}\n/**\n * Creates a new sorted array from a new change.\n * Build our own because we allow filtering of action types ('added', 'removed', 'modified') before scanning\n * and so we have greater control over change detection (by breaking ===)\n * @template T\n * @param {?} combined\n * @param {?} change\n * @return {?}\n */\n\n\nfunction combineChange(combined, change) {\n  switch (change.type) {\n    case 'added':\n      if (combined[change.newIndex] && combined[change.newIndex].doc.ref.isEqual(change.doc.ref)) {// Not sure why the duplicates are getting fired\n      } else {\n        return sliceAndSplice(combined, change.newIndex, 0, change);\n      }\n\n      break;\n\n    case 'modified':\n      if (combined[change.oldIndex] == null || combined[change.oldIndex].doc.ref.isEqual(change.doc.ref)) {\n        // When an item changes position we first remove it\n        // and then add it's new position\n        if (change.oldIndex !== change.newIndex) {\n          /** @type {?} */\n          var copiedArray = combined.slice();\n          copiedArray.splice(change.oldIndex, 1);\n          copiedArray.splice(change.newIndex, 0, change);\n          return copiedArray;\n        } else {\n          return sliceAndSplice(combined, change.newIndex, 1, change);\n        }\n      }\n\n      break;\n\n    case 'removed':\n      if (combined[change.oldIndex] && combined[change.oldIndex].doc.ref.isEqual(change.doc.ref)) {\n        return sliceAndSplice(combined, change.oldIndex, 1);\n      }\n\n      break;\n  }\n\n  return combined;\n}\n/**\n * @fileoverview added by tsickle\n * Generated from: collection/collection.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @param {?=} events\n * @return {?}\n */\n\n\nfunction validateEventsArray(events) {\n  if (!events || events.length === 0) {\n    events = ['added', 'removed', 'modified'];\n  }\n\n  return events;\n}\n/**\n * AngularFirestoreCollection service\n *\n * This class creates a reference to a Firestore Collection. A reference and a query are provided in\n * in the constructor. The query can be the unqueried reference if no query is desired.The class\n * is generic which gives you type safety for data update methods and data streaming.\n *\n * This class uses Symbol.observable to transform into Observable using Observable.from().\n *\n * This class is rarely used directly and should be created from the AngularFirestore service.\n *\n * Example:\n *\n * const collectionRef = firebase.firestore.collection('stocks');\n * const query = collectionRef.where('price', '>', '0.01');\n * const fakeStock = new AngularFirestoreCollection<Stock>(collectionRef, query);\n *\n * // NOTE!: the updates are performed on the reference not the query\n * await fakeStock.add({ name: 'FAKE', price: 0.01 });\n *\n * // Subscribe to changes as snapshots. This provides you data updates as well as delta updates.\n * fakeStock.valueChanges().subscribe(value => console.log(value));\n * @template T\n */\n\n\nvar AngularFirestoreCollection = /*#__PURE__*/function () {\n  /**\n   * The constructor takes in a CollectionReference and Query to provide wrapper methods\n   * for data operations and data streaming.\n   *\n   * Note: Data operation methods are done on the reference not the query. This means\n   * when you update data it is not updating data to the window of your query unless\n   * the data fits the criteria of the query. See the AssociatedRefence type for details\n   * on this implication.\n   * @param {?} ref\n   * @param {?} query\n   * @param {?} afs\n   */\n  function AngularFirestoreCollection(ref, query, afs) {\n    _classCallCheck(this, AngularFirestoreCollection);\n\n    this.ref = ref;\n    this.query = query;\n    this.afs = afs;\n  }\n  /**\n   * Listen to the latest change in the stream. This method returns changes\n   * as they occur and they are not sorted by query order. This allows you to construct\n   * your own data structure.\n   * @param {?=} events\n   * @return {?}\n   */\n\n\n  _createClass(AngularFirestoreCollection, [{\n    key: \"stateChanges\",\n    value: function stateChanges(events) {\n      /** @type {?} */\n      var source = docChanges(this.query, this.afs.schedulers.outsideAngular);\n\n      if (events && events.length > 0) {\n        source = source.pipe(map(\n        /**\n        * @param {?} actions\n        * @return {?}\n        */\n        function (actions) {\n          return actions.filter(\n          /**\n          * @param {?} change\n          * @return {?}\n          */\n          function (change) {\n            return events.indexOf(change.type) > -1;\n          });\n        }));\n      }\n\n      return source.pipe( // We want to filter out empty arrays, but always emit at first, so the developer knows\n      // that the collection has been resolve; even if it's empty\n      startWith(undefined), pairwise(), filter(\n      /**\n      * @param {?} __0\n      * @return {?}\n      */\n      function (_ref5) {\n        var _ref6 = _slicedToArray(_ref5, 2),\n            prior = _ref6[0],\n            current = _ref6[1];\n\n        return current.length > 0 || !prior;\n      }), map(\n      /**\n      * @param {?} __0\n      * @return {?}\n      */\n      function (_ref7) {\n        var _ref8 = _slicedToArray(_ref7, 2),\n            prior = _ref8[0],\n            current = _ref8[1];\n\n        return current;\n      }), this.afs.keepUnstableUntilFirst);\n    }\n    /**\n     * Create a stream of changes as they occur it time. This method is similar to stateChanges()\n     * but it collects each event in an array over time.\n     * @param {?=} events\n     * @return {?}\n     */\n\n  }, {\n    key: \"auditTrail\",\n    value: function auditTrail(events) {\n      return this.stateChanges(events).pipe(scan(\n      /**\n      * @param {?} current\n      * @param {?} action\n      * @return {?}\n      */\n      function (current, action) {\n        return [].concat(_toConsumableArray(current), _toConsumableArray(action));\n      }, []));\n    }\n    /**\n     * Create a stream of synchronized changes. This method keeps the local array in sorted\n     * query order.\n     * @param {?=} events\n     * @return {?}\n     */\n\n  }, {\n    key: \"snapshotChanges\",\n    value: function snapshotChanges(events) {\n      /** @type {?} */\n      var validatedEvents = validateEventsArray(events);\n      /** @type {?} */\n\n      var scheduledSortedChanges$ = sortedChanges(this.query, validatedEvents, this.afs.schedulers.outsideAngular);\n      return scheduledSortedChanges$.pipe(this.afs.keepUnstableUntilFirst);\n    }\n    /**\n     * @template K\n     * @param {?=} options\n     * @return {?}\n     */\n\n  }, {\n    key: \"valueChanges\",\n    value: function valueChanges() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      return fromCollectionRef(this.query, this.afs.schedulers.outsideAngular).pipe(map(\n      /**\n      * @param {?} actions\n      * @return {?}\n      */\n      function (actions) {\n        return actions.payload.docs.map(\n        /**\n        * @param {?} a\n        * @return {?}\n        */\n        function (a) {\n          if (options.idField) {\n            return (\n              /** @type {?} */\n              Object.assign(Object.assign({},\n              /** @type {?} */\n              a.data()), _defineProperty({}, options.idField, a.id))\n            );\n          } else {\n            return a.data();\n          }\n        });\n      }), this.afs.keepUnstableUntilFirst);\n    }\n    /**\n     * Retrieve the results of the query once.\n     * @param {?=} options\n     * @return {?}\n     */\n\n  }, {\n    key: \"get\",\n    value: function get(options) {\n      return from(this.query.get(options)).pipe(observeOn(this.afs.schedulers.insideAngular));\n    }\n    /**\n     * Add data to a collection reference.\n     *\n     * Note: Data operation methods are done on the reference not the query. This means\n     * when you update data it is not updating data to the window of your query unless\n     * the data fits the criteria of the query.\n     * @param {?} data\n     * @return {?}\n     */\n\n  }, {\n    key: \"add\",\n    value: function add(data) {\n      return this.ref.add(data);\n    }\n    /**\n     * Create a reference to a single document in a collection.\n     * @template T2\n     * @param {?=} path\n     * @return {?}\n     */\n\n  }, {\n    key: \"doc\",\n    value: function doc(path) {\n      // TODO is there a better way to solve this type issue\n      return new AngularFirestoreDocument(\n      /** @type {?} */\n      this.ref.doc(path), this.afs);\n    }\n  }]);\n\n  return AngularFirestoreCollection;\n}();\n\nif (false) {\n  /** @type {?} */\n  AngularFirestoreCollection.prototype.ref;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  AngularFirestoreCollection.prototype.query;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  AngularFirestoreCollection.prototype.afs;\n}\n/**\n * @fileoverview added by tsickle\n * Generated from: document/document.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * AngularFirestoreDocument service\n *\n * This class creates a reference to a Firestore Document. A reference is provided in\n * in the constructor. The class is generic which gives you type safety for data update\n * methods and data streaming.\n *\n * This class uses Symbol.observable to transform into Observable using Observable.from().\n *\n * This class is rarely used directly and should be created from the AngularFirestore service.\n *\n * Example:\n *\n * const fakeStock = new AngularFirestoreDocument<Stock>(doc('stocks/FAKE'));\n * await fakeStock.set({ name: 'FAKE', price: 0.01 });\n * fakeStock.valueChanges().map(snap => {\n *   if(snap.exists) return snap.data();\n *   return null;\n * }).subscribe(value => console.log(value));\n * // OR! Transform using Observable.from() and the data is unwrapped for you\n * Observable.from(fakeStock).subscribe(value => console.log(value));\n * @template T\n */\n\n\nvar AngularFirestoreDocument = /*#__PURE__*/function () {\n  /**\n   * The constructor takes in a DocumentReference to provide wrapper methods\n   * for data operations, data streaming, and Symbol.observable.\n   * @param {?} ref\n   * @param {?} afs\n   */\n  function AngularFirestoreDocument(ref, afs) {\n    _classCallCheck(this, AngularFirestoreDocument);\n\n    this.ref = ref;\n    this.afs = afs;\n  }\n  /**\n   * Create or overwrite a single document.\n   * @param {?} data\n   * @param {?=} options\n   * @return {?}\n   */\n\n\n  _createClass(AngularFirestoreDocument, [{\n    key: \"set\",\n    value: function set(data, options) {\n      return this.ref.set(data, options);\n    }\n    /**\n     * Update some fields of a document without overwriting the entire document.\n     * @param {?} data\n     * @return {?}\n     */\n\n  }, {\n    key: \"update\",\n    value: function update(data) {\n      return this.ref.update(data);\n    }\n    /**\n     * Delete a document.\n     * @return {?}\n     */\n\n  }, {\n    key: \"delete\",\n    value: function _delete() {\n      return this.ref.delete();\n    }\n    /**\n     * Create a reference to a sub-collection given a path and an optional query\n     * function.\n     * @template R\n     * @param {?} path\n     * @param {?=} queryFn\n     * @return {?}\n     */\n\n  }, {\n    key: \"collection\",\n    value: function collection(path, queryFn) {\n      /** @type {?} */\n      var collectionRef =\n      /** @type {?} */\n      this.ref.collection(path);\n\n      var _associateQuery = associateQuery(collectionRef, queryFn),\n          ref = _associateQuery.ref,\n          query = _associateQuery.query;\n\n      return new AngularFirestoreCollection(ref, query, this.afs);\n    }\n    /**\n     * Listen to snapshot updates from the document.\n     * @return {?}\n     */\n\n  }, {\n    key: \"snapshotChanges\",\n    value: function snapshotChanges() {\n      /** @type {?} */\n      var scheduledFromDocRef$ = fromDocRef(this.ref, this.afs.schedulers.outsideAngular);\n      return scheduledFromDocRef$.pipe(this.afs.keepUnstableUntilFirst);\n    }\n    /**\n     * @template K\n     * @param {?=} options\n     * @return {?}\n     */\n\n  }, {\n    key: \"valueChanges\",\n    value: function valueChanges() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      return this.snapshotChanges().pipe(map(\n      /**\n      * @param {?} __0\n      * @return {?}\n      */\n      function (_ref9) {\n        var payload = _ref9.payload;\n        return options.idField ?\n        /** @type {?} */\n        Object.assign(Object.assign({}, payload.data()), _defineProperty({}, options.idField, payload.id)) : payload.data();\n      }));\n    }\n    /**\n     * Retrieve the document once.\n     * @param {?=} options\n     * @return {?}\n     */\n\n  }, {\n    key: \"get\",\n    value: function get(options) {\n      return from(this.ref.get(options)).pipe(observeOn(this.afs.schedulers.insideAngular));\n    }\n  }]);\n\n  return AngularFirestoreDocument;\n}();\n\nif (false) {\n  /** @type {?} */\n  AngularFirestoreDocument.prototype.ref;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  AngularFirestoreDocument.prototype.afs;\n}\n/**\n * @fileoverview added by tsickle\n * Generated from: collection-group/collection-group.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * AngularFirestoreCollectionGroup service\n *\n * This class holds a reference to a Firestore Collection Group Query.\n *\n * This class uses Symbol.observable to transform into Observable using Observable.from().\n *\n * This class is rarely used directly and should be created from the AngularFirestore service.\n *\n * Example:\n *\n * const collectionGroup = firebase.firestore.collectionGroup('stocks');\n * const query = collectionRef.where('price', '>', '0.01');\n * const fakeStock = new AngularFirestoreCollectionGroup<Stock>(query, afs);\n *\n * // Subscribe to changes as snapshots. This provides you data updates as well as delta updates.\n * fakeStock.valueChanges().subscribe(value => console.log(value));\n * @template T\n */\n\n\nvar AngularFirestoreCollectionGroup = /*#__PURE__*/function () {\n  /**\n   * The constructor takes in a CollectionGroupQuery to provide wrapper methods\n   * for data operations and data streaming.\n   * @param {?} query\n   * @param {?} afs\n   */\n  function AngularFirestoreCollectionGroup(query, afs) {\n    _classCallCheck(this, AngularFirestoreCollectionGroup);\n\n    this.query = query;\n    this.afs = afs;\n  }\n  /**\n   * Listen to the latest change in the stream. This method returns changes\n   * as they occur and they are not sorted by query order. This allows you to construct\n   * your own data structure.\n   * @param {?=} events\n   * @return {?}\n   */\n\n\n  _createClass(AngularFirestoreCollectionGroup, [{\n    key: \"stateChanges\",\n    value: function stateChanges(events) {\n      if (!events || events.length === 0) {\n        return docChanges(this.query, this.afs.schedulers.outsideAngular).pipe(this.afs.keepUnstableUntilFirst);\n      }\n\n      return docChanges(this.query, this.afs.schedulers.outsideAngular).pipe(map(\n      /**\n      * @param {?} actions\n      * @return {?}\n      */\n      function (actions) {\n        return actions.filter(\n        /**\n        * @param {?} change\n        * @return {?}\n        */\n        function (change) {\n          return events.indexOf(change.type) > -1;\n        });\n      }), filter(\n      /**\n      * @param {?} changes\n      * @return {?}\n      */\n      function (changes) {\n        return changes.length > 0;\n      }), this.afs.keepUnstableUntilFirst);\n    }\n    /**\n     * Create a stream of changes as they occur it time. This method is similar to stateChanges()\n     * but it collects each event in an array over time.\n     * @param {?=} events\n     * @return {?}\n     */\n\n  }, {\n    key: \"auditTrail\",\n    value: function auditTrail(events) {\n      return this.stateChanges(events).pipe(scan(\n      /**\n      * @param {?} current\n      * @param {?} action\n      * @return {?}\n      */\n      function (current, action) {\n        return [].concat(_toConsumableArray(current), _toConsumableArray(action));\n      }, []));\n    }\n    /**\n     * Create a stream of synchronized changes. This method keeps the local array in sorted\n     * query order.\n     * @param {?=} events\n     * @return {?}\n     */\n\n  }, {\n    key: \"snapshotChanges\",\n    value: function snapshotChanges(events) {\n      /** @type {?} */\n      var validatedEvents = validateEventsArray(events);\n      /** @type {?} */\n\n      var scheduledSortedChanges$ = sortedChanges(this.query, validatedEvents, this.afs.schedulers.outsideAngular);\n      return scheduledSortedChanges$.pipe(this.afs.keepUnstableUntilFirst);\n    }\n    /**\n     * @template K\n     * @param {?=} options\n     * @return {?}\n     */\n\n  }, {\n    key: \"valueChanges\",\n    value: function valueChanges() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      /** @type {?} */\n      var fromCollectionRefScheduled$ = fromCollectionRef(this.query, this.afs.schedulers.outsideAngular);\n      return fromCollectionRefScheduled$.pipe(map(\n      /**\n      * @param {?} actions\n      * @return {?}\n      */\n      function (actions) {\n        return actions.payload.docs.map(\n        /**\n        * @param {?} a\n        * @return {?}\n        */\n        function (a) {\n          if (options.idField) {\n            return (\n              /** @type {?} */\n              Object.assign(_defineProperty({}, options.idField, a.id), a.data())\n            );\n          } else {\n            return a.data();\n          }\n        });\n      }), this.afs.keepUnstableUntilFirst);\n    }\n    /**\n     * Retrieve the results of the query once.\n     * @param {?=} options\n     * @return {?}\n     */\n\n  }, {\n    key: \"get\",\n    value: function get(options) {\n      return from(this.query.get(options)).pipe(observeOn(this.afs.schedulers.insideAngular));\n    }\n  }]);\n\n  return AngularFirestoreCollectionGroup;\n}();\n\nif (false) {\n  /**\n   * @type {?}\n   * @private\n   */\n  AngularFirestoreCollectionGroup.prototype.query;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  AngularFirestoreCollectionGroup.prototype.afs;\n}\n/**\n * @fileoverview added by tsickle\n * Generated from: firestore.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * The value of this token determines whether or not the firestore will have persistance enabled\n * @type {?}\n */\n\n\nvar ENABLE_PERSISTENCE = new InjectionToken('angularfire2.enableFirestorePersistence');\n/** @type {?} */\n\nvar PERSISTENCE_SETTINGS = new InjectionToken('angularfire2.firestore.persistenceSettings');\n/** @type {?} */\n\nvar SETTINGS = new InjectionToken('angularfire2.firestore.settings');\n/** @type {?} */\n\nvar USE_EMULATOR = new InjectionToken('angularfire2.firestore.use-emulator');\n/**\n * A utility methods for associating a collection reference with\n * a query.\n *\n * @template T\n * @param {?} collectionRef - A collection reference to query\n * @param {?=} queryFn - The callback to create a query\n *\n * Example:\n * const { query, ref } = associateQuery(docRef.collection('items'), ref => {\n *  return ref.where('age', '<', 200);\n * });\n * @return {?}\n */\n\nfunction associateQuery(collectionRef) {\n  var queryFn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] :\n  /**\n  * @param {?} ref\n  * @return {?}\n  */\n  function (ref) {\n    return ref;\n  };\n\n  /** @type {?} */\n  var query = queryFn(collectionRef);\n  /** @type {?} */\n\n  var ref = collectionRef;\n  return {\n    query: query,\n    ref: ref\n  };\n}\n/**\n * AngularFirestore Service\n *\n * This service is the main entry point for this feature module. It provides\n * an API for creating Collection and Reference services. These services can\n * then be used to do data updates and observable streams of the data.\n *\n * Example:\n *\n * import { Component } from '\\@angular/core';\n * import { AngularFirestore, AngularFirestoreCollection, AngularFirestoreDocument } from '\\@angular/fire/firestore';\n * import { Observable } from 'rxjs/Observable';\n * import { from } from 'rxjs/observable';\n *\n * \\@Component({\n *   selector: 'app-my-component',\n *   template: `\n *    <h2>Items for {{ (profile | async)?.name }}\n *    <ul>\n *       <li *ngFor=\"let item of items | async\">{{ item.name }}</li>\n *    </ul>\n *    <div class=\"control-input\">\n *       <input type=\"text\" #itemname />\n *       <button (click)=\"addItem(itemname.value)\">Add Item</button>\n *    </div>\n *   `\n * })\n * export class MyComponent implements OnInit {\n *\n *   // services for data operations and data streaming\n *   private readonly itemsRef: AngularFirestoreCollection<Item>;\n *   private readonly profileRef: AngularFirestoreDocument<Profile>;\n *\n *   // observables for template\n *   items: Observable<Item[]>;\n *   profile: Observable<Profile>;\n *\n *   // inject main service\n *   constructor(private readonly afs: AngularFirestore) {}\n *\n *   ngOnInit() {\n *     this.itemsRef = afs.collection('items', ref => ref.where('user', '==', 'davideast').limit(10));\n *     this.items = this.itemsRef.valueChanges().map(snap => snap.docs.map(data => doc.data()));\n *     // this.items = from(this.itemsRef); // you can also do this with no mapping\n *\n *     this.profileRef = afs.doc('users/davideast');\n *     this.profile = this.profileRef.valueChanges();\n *   }\n *\n *   addItem(name: string) {\n *     const user = 'davideast';\n *     this.itemsRef.add({ name, user });\n *   }\n * }\n */\n\n\nvar AngularFirestore = /*#__PURE__*/function () {\n  /**\n   * Each Feature of AngularFire has a FirebaseApp injected. This way we\n   * don't rely on the main Firebase App instance and we can create named\n   * apps and use multiple apps.\n   * @param {?} options\n   * @param {?} nameOrConfig\n   * @param {?} shouldEnablePersistence\n   * @param {?} settings\n   * @param {?} platformId\n   * @param {?} zone\n   * @param {?} persistenceSettings\n   * @param {?} _useEmulator\n   * @param {?} useAuthEmulator\n   */\n  function AngularFirestore(options, nameOrConfig, shouldEnablePersistence, settings, // tslint:disable-next-line:ban-types\n  platformId, zone, persistenceSettings, _useEmulator, useAuthEmulator) {\n    _classCallCheck(this, AngularFirestore);\n\n    this.schedulers = new ɵAngularFireSchedulers(zone);\n    this.keepUnstableUntilFirst = ɵkeepUnstableUntilFirstFactory(this.schedulers);\n    /** @type {?} */\n\n    var app = ɵfirebaseAppFactory(options, zone, nameOrConfig);\n\n    if (!firebase.auth && useAuthEmulator) {\n      ɵlogAuthEmulatorError();\n    }\n    /** @type {?} */\n\n\n    var useEmulator = _useEmulator;\n\n    var _fetchInstance = ɵfetchInstance(\"\".concat(app.name, \".firestore\"), 'AngularFirestore', app,\n    /**\n    * @return {?}\n    */\n    function () {\n      /** @type {?} */\n      var firestore = zone.runOutsideAngular(\n      /**\n      * @return {?}\n      */\n      function () {\n        return app.firestore();\n      });\n\n      if (settings) {\n        firestore.settings(settings);\n      }\n\n      if (useEmulator) {\n        firestore.useEmulator.apply(firestore, _toConsumableArray(useEmulator));\n      }\n\n      if (shouldEnablePersistence && !isPlatformServer(platformId)) {\n        // We need to try/catch here because not all enablePersistence() failures are caught\n        // https://github.com/firebase/firebase-js-sdk/issues/608\n\n        /** @type {?} */\n        var enablePersistence =\n        /**\n        * @return {?}\n        */\n        function enablePersistence() {\n          try {\n            return from(firestore.enablePersistence(persistenceSettings || undefined).then(\n            /**\n            * @return {?}\n            */\n            function () {\n              return true;\n            },\n            /**\n            * @return {?}\n            */\n            function () {\n              return false;\n            }));\n          } catch (e) {\n            if (typeof console !== 'undefined') {\n              console.warn(e);\n            }\n\n            return of(false);\n          }\n        };\n\n        return [firestore, zone.runOutsideAngular(enablePersistence)];\n      } else {\n        return [firestore, of(false)];\n      }\n    }, [settings, useEmulator, shouldEnablePersistence]);\n\n    var _fetchInstance2 = _slicedToArray(_fetchInstance, 2);\n\n    this.firestore = _fetchInstance2[0];\n    this.persistenceEnabled$ = _fetchInstance2[1];\n  }\n  /**\n   * @template T\n   * @param {?} pathOrRef\n   * @param {?=} queryFn\n   * @return {?}\n   */\n\n\n  _createClass(AngularFirestore, [{\n    key: \"collection\",\n    value: function collection(pathOrRef, queryFn) {\n      /** @type {?} */\n      var collectionRef;\n\n      if (typeof pathOrRef === 'string') {\n        collectionRef =\n        /** @type {?} */\n        this.firestore.collection(pathOrRef);\n      } else {\n        collectionRef = pathOrRef;\n      }\n\n      var _associateQuery2 = associateQuery(collectionRef, queryFn),\n          ref = _associateQuery2.ref,\n          query = _associateQuery2.query;\n      /** @type {?} */\n\n\n      var refInZone = this.schedulers.ngZone.run(\n      /**\n      * @return {?}\n      */\n      function () {\n        return ref;\n      });\n      return new AngularFirestoreCollection(refInZone, query, this);\n    }\n    /**\n     * Create a reference to a Firestore Collection Group based on a collectionId\n     * and an optional query function to narrow the result\n     * set.\n     * @template T\n     * @param {?} collectionId\n     * @param {?=} queryGroupFn\n     * @return {?}\n     */\n\n  }, {\n    key: \"collectionGroup\",\n    value: function collectionGroup(collectionId, queryGroupFn) {\n      /** @type {?} */\n      var queryFn = queryGroupFn ||\n      /**\n      * @param {?} ref\n      * @return {?}\n      */\n      function (ref) {\n        return ref;\n      };\n      /** @type {?} */\n\n\n      var collectionGroup =\n      /** @type {?} */\n      this.firestore.collectionGroup(collectionId);\n      return new AngularFirestoreCollectionGroup(queryFn(collectionGroup), this);\n    }\n    /**\n     * @template T\n     * @param {?} pathOrRef\n     * @return {?}\n     */\n\n  }, {\n    key: \"doc\",\n    value: function doc(pathOrRef) {\n      /** @type {?} */\n      var ref;\n\n      if (typeof pathOrRef === 'string') {\n        ref =\n        /** @type {?} */\n        this.firestore.doc(pathOrRef);\n      } else {\n        ref = pathOrRef;\n      }\n      /** @type {?} */\n\n\n      var refInZone = this.schedulers.ngZone.run(\n      /**\n      * @return {?}\n      */\n      function () {\n        return ref;\n      });\n      return new AngularFirestoreDocument(refInZone, this);\n    }\n    /**\n     * Returns a generated Firestore Document Id.\n     * @return {?}\n     */\n\n  }, {\n    key: \"createId\",\n    value: function createId() {\n      return this.firestore.collection('_').doc().id;\n    }\n  }]);\n\n  return AngularFirestore;\n}();\n\nAngularFirestore.decorators = [{\n  type: Injectable,\n  args: [{\n    providedIn: 'any'\n  }]\n}];\n/** @nocollapse */\n\nAngularFirestore.ctorParameters = function () {\n  return [{\n    type: undefined,\n    decorators: [{\n      type: Inject,\n      args: [FIREBASE_OPTIONS]\n    }]\n  }, {\n    type: undefined,\n    decorators: [{\n      type: Optional\n    }, {\n      type: Inject,\n      args: [FIREBASE_APP_NAME]\n    }]\n  }, {\n    type: undefined,\n    decorators: [{\n      type: Optional\n    }, {\n      type: Inject,\n      args: [ENABLE_PERSISTENCE]\n    }]\n  }, {\n    type: undefined,\n    decorators: [{\n      type: Optional\n    }, {\n      type: Inject,\n      args: [SETTINGS]\n    }]\n  }, {\n    type: Object,\n    decorators: [{\n      type: Inject,\n      args: [PLATFORM_ID]\n    }]\n  }, {\n    type: NgZone\n  }, {\n    type: undefined,\n    decorators: [{\n      type: Optional\n    }, {\n      type: Inject,\n      args: [PERSISTENCE_SETTINGS]\n    }]\n  }, {\n    type: undefined,\n    decorators: [{\n      type: Optional\n    }, {\n      type: Inject,\n      args: [USE_EMULATOR]\n    }]\n  }, {\n    type: undefined,\n    decorators: [{\n      type: Optional\n    }, {\n      type: Inject,\n      args: [USE_EMULATOR$1]\n    }]\n  }];\n};\n/** @nocollapse */\n\n\nAngularFirestore.ɵprov = ɵɵdefineInjectable({\n  factory: function AngularFirestore_Factory() {\n    return new AngularFirestore(ɵɵinject(FIREBASE_OPTIONS), ɵɵinject(FIREBASE_APP_NAME, 8), ɵɵinject(ENABLE_PERSISTENCE, 8), ɵɵinject(SETTINGS, 8), ɵɵinject(PLATFORM_ID), ɵɵinject(NgZone), ɵɵinject(PERSISTENCE_SETTINGS, 8), ɵɵinject(USE_EMULATOR, 8), ɵɵinject(USE_EMULATOR$1, 8));\n  },\n  token: AngularFirestore,\n  providedIn: \"any\"\n});\n\nif (false) {\n  /** @type {?} */\n  AngularFirestore.prototype.firestore;\n  /** @type {?} */\n\n  AngularFirestore.prototype.persistenceEnabled$;\n  /** @type {?} */\n\n  AngularFirestore.prototype.schedulers;\n  /** @type {?} */\n\n  AngularFirestore.prototype.keepUnstableUntilFirst;\n}\n/**\n * @fileoverview added by tsickle\n * Generated from: firestore.module.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nvar AngularFirestoreModule = /*#__PURE__*/function () {\n  function AngularFirestoreModule() {\n    _classCallCheck(this, AngularFirestoreModule);\n  }\n\n  _createClass(AngularFirestoreModule, null, [{\n    key: \"enablePersistence\",\n\n    /**\n     * Attempt to enable persistent storage, if possible\n     * @param {?=} persistenceSettings\n     * @return {?}\n     */\n    value: function enablePersistence(persistenceSettings) {\n      return {\n        ngModule: AngularFirestoreModule,\n        providers: [{\n          provide: ENABLE_PERSISTENCE,\n          useValue: true\n        }, {\n          provide: PERSISTENCE_SETTINGS,\n          useValue: persistenceSettings\n        }]\n      };\n    }\n  }]);\n\n  return AngularFirestoreModule;\n}();\n\nAngularFirestoreModule.decorators = [{\n  type: NgModule,\n  args: [{\n    providers: [AngularFirestore]\n  }]\n}];\n/**\n * @fileoverview added by tsickle\n * Generated from: interfaces.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @record\n * @template T\n */\n\nfunction DocumentSnapshotExists() {}\n\nif (false) {\n  /** @type {?} */\n  DocumentSnapshotExists.prototype.exists;\n  /**\n   * @param {?=} options\n   * @return {?}\n   */\n\n  DocumentSnapshotExists.prototype.data = function (options) {};\n}\n/**\n * @record\n */\n\n\nfunction DocumentSnapshotDoesNotExist() {}\n\nif (false) {\n  /** @type {?} */\n  DocumentSnapshotDoesNotExist.prototype.exists;\n  /**\n   * @param {?=} options\n   * @return {?}\n   */\n\n  DocumentSnapshotDoesNotExist.prototype.data = function (options) {};\n  /**\n   * @param {?} fieldPath\n   * @param {?=} options\n   * @return {?}\n   */\n\n\n  DocumentSnapshotDoesNotExist.prototype.get = function (fieldPath, options) {};\n}\n/**\n * @record\n * @template T\n */\n\n\nfunction QueryDocumentSnapshot() {}\n\nif (false) {\n  /**\n   * @param {?=} options\n   * @return {?}\n   */\n  QueryDocumentSnapshot.prototype.data = function (options) {};\n}\n/**\n * @record\n * @template T\n */\n\n\nfunction QuerySnapshot() {}\n\nif (false) {\n  /** @type {?} */\n  QuerySnapshot.prototype.docs;\n}\n/**\n * @record\n * @template T\n */\n\n\nfunction DocumentChange() {}\n\nif (false) {\n  /** @type {?} */\n  DocumentChange.prototype.doc;\n}\n/**\n * @record\n * @template T\n */\n\n\nfunction DocumentChangeAction() {}\n\nif (false) {\n  /** @type {?} */\n  DocumentChangeAction.prototype.type;\n  /** @type {?} */\n\n  DocumentChangeAction.prototype.payload;\n}\n/**\n * @record\n * @template T\n */\n\n\nfunction Action() {}\n\nif (false) {\n  /** @type {?} */\n  Action.prototype.type;\n  /** @type {?} */\n\n  Action.prototype.payload;\n}\n/**\n * @record\n * @template T\n */\n\n\nfunction Reference() {}\n\nif (false) {\n  /** @type {?} */\n  Reference.prototype.onSnapshot;\n}\n/**\n * A structure that provides an association between a reference\n * and a query on that reference. Note: Performing operations\n * on the reference can lead to confusing results with complicated\n * queries.\n *\n * Example:\n *\n * const query = ref.where('type', '==', 'Book').\n *                  .where('price', '>' 18.00)\n *                  .where('price', '<' 100.00)\n *                  .where('category', '==', 'Fiction')\n *                  .where('publisher', '==', 'BigPublisher')\n *\n * // This addition would not be a result of the query above\n * ref.add({\n *  type: 'Magazine',\n *  price: 4.99,\n *  category: 'Sports',\n *  publisher: 'SportsPublisher'\n * });\n * @record\n * @template T\n */\n\n\nfunction AssociatedReference() {}\n\nif (false) {\n  /** @type {?} */\n  AssociatedReference.prototype.ref;\n  /** @type {?} */\n\n  AssociatedReference.prototype.query;\n}\n/**\n * @fileoverview added by tsickle\n * Generated from: public_api.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * Generated from: angular-fire-firestore.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nexport { AngularFirestore, AngularFirestoreCollection, AngularFirestoreCollectionGroup, AngularFirestoreDocument, AngularFirestoreModule, ENABLE_PERSISTENCE, PERSISTENCE_SETTINGS, SETTINGS, USE_EMULATOR, associateQuery, combineChange, combineChanges, docChanges, fromCollectionRef, fromDocRef, fromRef, sortedChanges, validateEventsArray };","map":{"version":3,"sources":["../../../src/firestore/observable/fromRef.ts","../../../src/firestore/collection/changes.ts","../../../src/firestore/collection/collection.ts","../../../src/firestore/document/document.ts","../../../src/firestore/collection-group/collection-group.ts","../../../src/firestore/firestore.ts","../../../src/firestore/firestore.module.ts","../../../src/firestore/interfaces.ts"],"names":["USE_AUTH_EMULATOR"],"mappings":"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","sourcesContent":["import { asyncScheduler, Observable, SchedulerLike } from 'rxjs';\nimport { Action, DocumentReference, DocumentSnapshot, Query, QuerySnapshot, Reference } from '../interfaces';\nimport { map, pairwise, startWith } from 'rxjs/operators';\n\nfunction _fromRef<T, R>(ref: Reference<T>, scheduler: SchedulerLike = asyncScheduler): Observable<R> {\n  return new Observable(subscriber => {\n    let unsubscribe: () => void;\n    if (scheduler != null) {\n      scheduler.schedule(() => {\n        unsubscribe = ref.onSnapshot({ includeMetadataChanges: true }, subscriber);\n      });\n    } else {\n      unsubscribe = ref.onSnapshot({ includeMetadataChanges: true }, subscriber);\n    }\n\n    return () => {\n      if (unsubscribe != null) {\n        unsubscribe();\n      }\n    };\n  });\n}\n\nexport function fromRef<R, T>(ref: DocumentReference<T> | Query<T>, scheduler?: SchedulerLike) {\n  return _fromRef<typeof ref, R>(ref, scheduler);\n}\n\nexport function fromDocRef<T>(ref: DocumentReference<T>, scheduler?: SchedulerLike): Observable<Action<DocumentSnapshot<T>>> {\n  return fromRef<DocumentSnapshot<T>, T>(ref, scheduler)\n    .pipe(\n      startWith(undefined),\n      pairwise(),\n      map(([priorPayload, payload]) => {\n        if (!payload.exists) {\n          return { payload, type: 'removed' };\n        }\n        if (!priorPayload?.exists) {\n          return { payload, type: 'added' };\n        }\n        return { payload, type: 'modified' };\n      })\n    );\n}\n\nexport function fromCollectionRef<T>(ref: Query<T>, scheduler?: SchedulerLike): Observable<Action<QuerySnapshot<T>>> {\n  return fromRef<QuerySnapshot<T>, T>(ref, scheduler).pipe(map(payload => ({ payload, type: 'query' })));\n}\n","import { fromCollectionRef } from '../observable/fromRef';\nimport { Observable, SchedulerLike } from 'rxjs';\nimport { distinctUntilChanged, map, pairwise, scan, startWith } from 'rxjs/operators';\nimport { DocumentChange, DocumentChangeAction, DocumentChangeType, Query } from '../interfaces';\n\n/**\n * Return a stream of document changes on a query. These results are not in sort order but in\n * order of occurence.\n */\nexport function docChanges<T>(query: Query, scheduler?: SchedulerLike): Observable<DocumentChangeAction<T>[]> {\n  return fromCollectionRef(query, scheduler)\n    .pipe(\n      startWith(undefined),\n      pairwise(),\n      map(([priorAction, action]) => {\n        const docChanges = action.payload.docChanges();\n        const actions = docChanges.map(change => ({ type: change.type, payload: change }));\n        // the metadata has changed from the prior emission\n        if (priorAction && JSON.stringify(priorAction.payload.metadata) !== JSON.stringify(action.payload.metadata)) {\n          // go through all the docs in payload and figure out which ones changed\n          action.payload.docs.forEach((currentDoc, currentIndex) => {\n            const docChange = docChanges.find(d => d.doc.ref.isEqual(currentDoc.ref));\n            const priorDoc = priorAction?.payload.docs.find(d => d.ref.isEqual(currentDoc.ref));\n            if (docChange && JSON.stringify(docChange.doc.metadata) === JSON.stringify(currentDoc.metadata) ||\n              !docChange && priorDoc && JSON.stringify(priorDoc.metadata) === JSON.stringify(currentDoc.metadata)) {\n              // document doesn't appear to have changed, don't log another action\n            } else {\n              // since the actions are processed in order just push onto the array\n              actions.push({\n                type: 'modified',\n                payload: {\n                  oldIndex: currentIndex,\n                  newIndex: currentIndex,\n                  type: 'modified',\n                  doc: currentDoc\n                }\n              });\n            }\n          });\n        }\n        return actions as DocumentChangeAction<T>[];\n      }),\n  );\n}\n\n/**\n * Return a stream of document changes on a query. These results are in sort order.\n */\nexport function sortedChanges<T>(\n  query: Query,\n  events: DocumentChangeType[],\n  scheduler?: SchedulerLike): Observable<DocumentChangeAction<T>[]> {\n  return docChanges<T>(query, scheduler)\n    .pipe(\n      scan((current, changes) => combineChanges<T>(current, changes.map(it => it.payload), events), []),\n      distinctUntilChanged(), // cut down on unneed change cycles\n      map(changes => changes.map(c => ({ type: c.type, payload: c } as DocumentChangeAction<T>))));\n}\n\n/**\n * Combines the total result set from the current set of changes from an incoming set\n * of changes.\n */\nexport function combineChanges<T>(current: DocumentChange<T>[], changes: DocumentChange<T>[], events: DocumentChangeType[]) {\n  changes.forEach(change => {\n    // skip unwanted change types\n    if (events.indexOf(change.type) > -1) {\n      current = combineChange(current, change);\n    }\n  });\n  return current;\n}\n\n/**\n * Splice arguments on top of a sliced array, to break top-level ===\n * this is useful for change-detection\n */\nfunction sliceAndSplice<T>(\n  original: T[],\n  start: number,\n  deleteCount: number,\n  ...args: T[]\n): T[] {\n  const returnArray = original.slice();\n  returnArray.splice(start, deleteCount, ...args);\n  return returnArray;\n}\n\n/**\n * Creates a new sorted array from a new change.\n * Build our own because we allow filtering of action types ('added', 'removed', 'modified') before scanning\n * and so we have greater control over change detection (by breaking ===)\n */\nexport function combineChange<T>(combined: DocumentChange<T>[], change: DocumentChange<T>): DocumentChange<T>[] {\n  switch (change.type) {\n    case 'added':\n      if (combined[change.newIndex] && combined[change.newIndex].doc.ref.isEqual(change.doc.ref)) {\n        // Not sure why the duplicates are getting fired\n      } else {\n        return sliceAndSplice(combined, change.newIndex, 0, change);\n      }\n      break;\n    case 'modified':\n      if (combined[change.oldIndex] == null || combined[change.oldIndex].doc.ref.isEqual(change.doc.ref)) {\n        // When an item changes position we first remove it\n        // and then add it's new position\n        if (change.oldIndex !== change.newIndex) {\n          const copiedArray = combined.slice();\n          copiedArray.splice(change.oldIndex, 1);\n          copiedArray.splice(change.newIndex, 0, change);\n          return copiedArray;\n        } else {\n          return sliceAndSplice(combined, change.newIndex, 1, change);\n        }\n      }\n      break;\n    case 'removed':\n      if (combined[change.oldIndex] && combined[change.oldIndex].doc.ref.isEqual(change.doc.ref)) {\n        return sliceAndSplice(combined, change.oldIndex, 1);\n      }\n      break;\n  }\n  return combined;\n}\n","import { from, Observable } from 'rxjs';\nimport { fromCollectionRef } from '../observable/fromRef';\nimport { filter, map, observeOn, pairwise, scan, startWith } from 'rxjs/operators';\nimport firebase from 'firebase/app';\n\nimport { CollectionReference, DocumentChangeAction, DocumentChangeType, DocumentData, DocumentReference, Query } from '../interfaces';\nimport { docChanges, sortedChanges } from './changes';\nimport { AngularFirestoreDocument } from '../document/document';\nimport { AngularFirestore } from '../firestore';\n\nexport function validateEventsArray(events?: DocumentChangeType[]) {\n  if (!events || events.length === 0) {\n    events = ['added', 'removed', 'modified'];\n  }\n  return events;\n}\n\n/**\n * AngularFirestoreCollection service\n *\n * This class creates a reference to a Firestore Collection. A reference and a query are provided in\n * in the constructor. The query can be the unqueried reference if no query is desired.The class\n * is generic which gives you type safety for data update methods and data streaming.\n *\n * This class uses Symbol.observable to transform into Observable using Observable.from().\n *\n * This class is rarely used directly and should be created from the AngularFirestore service.\n *\n * Example:\n *\n * const collectionRef = firebase.firestore.collection('stocks');\n * const query = collectionRef.where('price', '>', '0.01');\n * const fakeStock = new AngularFirestoreCollection<Stock>(collectionRef, query);\n *\n * // NOTE!: the updates are performed on the reference not the query\n * await fakeStock.add({ name: 'FAKE', price: 0.01 });\n *\n * // Subscribe to changes as snapshots. This provides you data updates as well as delta updates.\n * fakeStock.valueChanges().subscribe(value => console.log(value));\n */\nexport class AngularFirestoreCollection<T = DocumentData> {\n  /**\n   * The constructor takes in a CollectionReference and Query to provide wrapper methods\n   * for data operations and data streaming.\n   *\n   * Note: Data operation methods are done on the reference not the query. This means\n   * when you update data it is not updating data to the window of your query unless\n   * the data fits the criteria of the query. See the AssociatedRefence type for details\n   * on this implication.\n   */\n  constructor(\n    public readonly ref: CollectionReference<T>,\n    private readonly query: Query<T>,\n    private readonly afs: AngularFirestore) { }\n\n  /**\n   * Listen to the latest change in the stream. This method returns changes\n   * as they occur and they are not sorted by query order. This allows you to construct\n   * your own data structure.\n   */\n  stateChanges(events?: DocumentChangeType[]): Observable<DocumentChangeAction<T>[]> {\n    let source = docChanges<T>(this.query, this.afs.schedulers.outsideAngular);\n    if (events && events.length > 0) {\n      source = source.pipe(\n        map(actions => actions.filter(change => events.indexOf(change.type) > -1))\n      );\n    }\n    return source.pipe(\n      // We want to filter out empty arrays, but always emit at first, so the developer knows\n      // that the collection has been resolve; even if it's empty\n      startWith(undefined),\n      pairwise(),\n      filter(([prior, current]) => current.length > 0 || !prior),\n      map(([prior, current]) => current),\n      this.afs.keepUnstableUntilFirst\n    );\n  }\n\n  /**\n   * Create a stream of changes as they occur it time. This method is similar to stateChanges()\n   * but it collects each event in an array over time.\n   */\n  auditTrail(events?: DocumentChangeType[]): Observable<DocumentChangeAction<T>[]> {\n    return this.stateChanges(events).pipe(scan((current, action) => [...current, ...action], []));\n  }\n\n  /**\n   * Create a stream of synchronized changes. This method keeps the local array in sorted\n   * query order.\n   */\n  snapshotChanges(events?: DocumentChangeType[]): Observable<DocumentChangeAction<T>[]> {\n    const validatedEvents = validateEventsArray(events);\n    const scheduledSortedChanges$ = sortedChanges<T>(this.query, validatedEvents, this.afs.schedulers.outsideAngular);\n    return scheduledSortedChanges$.pipe(\n      this.afs.keepUnstableUntilFirst\n    );\n  }\n\n  /**\n   * Listen to all documents in the collection and its possible query as an Observable.\n   *\n   * If the `idField` option is provided, document IDs are included and mapped to the\n   * provided `idField` property name.\n   */\n  valueChanges(): Observable<T[]>;\n  // tslint:disable-next-line:unified-signatures\n  valueChanges({}): Observable<T[]>;\n  valueChanges<K extends string>(options: {idField: K}): Observable<(T & { [T in K]: string })[]>;\n  valueChanges<K extends string>(options: {idField?: K} = {}): Observable<T[]> {\n    return fromCollectionRef<T>(this.query, this.afs.schedulers.outsideAngular)\n      .pipe(\n        map(actions => actions.payload.docs.map(a => {\n          if (options.idField) {\n            return {\n              ...a.data() as {},\n              ...{ [options.idField]: a.id }\n            } as T & { [T in K]: string };\n          } else {\n            return a.data();\n          }\n        })),\n        this.afs.keepUnstableUntilFirst\n      );\n  }\n\n  /**\n   * Retrieve the results of the query once.\n   */\n  get(options?: firebase.firestore.GetOptions) {\n    return from(this.query.get(options)).pipe(\n      observeOn(this.afs.schedulers.insideAngular),\n    );\n  }\n\n  /**\n   * Add data to a collection reference.\n   *\n   * Note: Data operation methods are done on the reference not the query. This means\n   * when you update data it is not updating data to the window of your query unless\n   * the data fits the criteria of the query.\n   */\n  add(data: T): Promise<DocumentReference<T>> {\n    return this.ref.add(data);\n  }\n\n  /**\n   * Create a reference to a single document in a collection.\n   */\n  doc<T2 = T>(path?: string): AngularFirestoreDocument<T2> {\n    // TODO is there a better way to solve this type issue\n    return new AngularFirestoreDocument(this.ref.doc(path) as any, this.afs);\n  }\n}\n","import { from, Observable } from 'rxjs';\nimport { Action, DocumentData, DocumentReference, DocumentSnapshot, QueryFn, SetOptions } from '../interfaces';\nimport { fromDocRef } from '../observable/fromRef';\nimport { map, observeOn } from 'rxjs/operators';\nimport { AngularFirestore, associateQuery } from '../firestore';\nimport { AngularFirestoreCollection } from '../collection/collection';\nimport firebase from 'firebase/app';\n\n/**\n * AngularFirestoreDocument service\n *\n * This class creates a reference to a Firestore Document. A reference is provided in\n * in the constructor. The class is generic which gives you type safety for data update\n * methods and data streaming.\n *\n * This class uses Symbol.observable to transform into Observable using Observable.from().\n *\n * This class is rarely used directly and should be created from the AngularFirestore service.\n *\n * Example:\n *\n * const fakeStock = new AngularFirestoreDocument<Stock>(doc('stocks/FAKE'));\n * await fakeStock.set({ name: 'FAKE', price: 0.01 });\n * fakeStock.valueChanges().map(snap => {\n *   if(snap.exists) return snap.data();\n *   return null;\n * }).subscribe(value => console.log(value));\n * // OR! Transform using Observable.from() and the data is unwrapped for you\n * Observable.from(fakeStock).subscribe(value => console.log(value));\n */\nexport class AngularFirestoreDocument<T = DocumentData> {\n\n  /**\n   * The constructor takes in a DocumentReference to provide wrapper methods\n   * for data operations, data streaming, and Symbol.observable.\n   */\n  constructor(public ref: DocumentReference<T>, private afs: AngularFirestore) { }\n\n  /**\n   * Create or overwrite a single document.\n   */\n  set(data: T, options?: SetOptions): Promise<void> {\n    return this.ref.set(data, options);\n  }\n\n  /**\n   * Update some fields of a document without overwriting the entire document.\n   */\n  update(data: Partial<T>): Promise<void> {\n    return this.ref.update(data);\n  }\n\n  /**\n   * Delete a document.\n   */\n  delete(): Promise<void> {\n    return this.ref.delete();\n  }\n\n  /**\n   * Create a reference to a sub-collection given a path and an optional query\n   * function.\n   */\n  collection<R = DocumentData>(path: string, queryFn?: QueryFn): AngularFirestoreCollection<R> {\n    const collectionRef = this.ref.collection(path) as firebase.firestore.CollectionReference<R>;\n    const { ref, query } = associateQuery(collectionRef, queryFn);\n    return new AngularFirestoreCollection(ref, query, this.afs);\n  }\n\n  /**\n   * Listen to snapshot updates from the document.\n   */\n  snapshotChanges(): Observable<Action<DocumentSnapshot<T>>> {\n    const scheduledFromDocRef$ = fromDocRef<T>(this.ref, this.afs.schedulers.outsideAngular);\n    return scheduledFromDocRef$.pipe(\n      this.afs.keepUnstableUntilFirst\n    );\n  }\n\n  /**\n   * Listen to unwrapped snapshot updates from the document.\n   *\n   * If the `idField` option is provided, document IDs are included and mapped to the\n   * provided `idField` property name.\n   */\n  valueChanges(options?: { }): Observable<T | undefined>;\n  valueChanges<K extends string>(options: { idField: K }): Observable<(T & { [T in K]: string }) | undefined>;\n  valueChanges<K extends string>(options: { idField?: K } = {}): Observable<T | undefined> {\n    return this.snapshotChanges().pipe(\n      map(({ payload }) =>\n        options.idField ? {\n          ...payload.data(),\n          ...{ [options.idField]: payload.id }\n        } as T & { [T in K]: string } : payload.data()\n      )\n    );\n  }\n\n  /**\n   * Retrieve the document once.\n   */\n  get(options?: firebase.firestore.GetOptions) {\n    return from(this.ref.get(options)).pipe(\n      observeOn(this.afs.schedulers.insideAngular),\n    );\n  }\n}\n","import { from, Observable } from 'rxjs';\nimport { fromCollectionRef } from '../observable/fromRef';\nimport { filter, map, observeOn, scan } from 'rxjs/operators';\nimport firebase from 'firebase/app';\n\nimport { DocumentChangeAction, DocumentChangeType, DocumentData, Query } from '../interfaces';\nimport { validateEventsArray } from '../collection/collection';\nimport { docChanges, sortedChanges } from '../collection/changes';\nimport { AngularFirestore } from '../firestore';\n\n/**\n * AngularFirestoreCollectionGroup service\n *\n * This class holds a reference to a Firestore Collection Group Query.\n *\n * This class uses Symbol.observable to transform into Observable using Observable.from().\n *\n * This class is rarely used directly and should be created from the AngularFirestore service.\n *\n * Example:\n *\n * const collectionGroup = firebase.firestore.collectionGroup('stocks');\n * const query = collectionRef.where('price', '>', '0.01');\n * const fakeStock = new AngularFirestoreCollectionGroup<Stock>(query, afs);\n *\n * // Subscribe to changes as snapshots. This provides you data updates as well as delta updates.\n * fakeStock.valueChanges().subscribe(value => console.log(value));\n */\nexport class AngularFirestoreCollectionGroup<T = DocumentData> {\n  /**\n   * The constructor takes in a CollectionGroupQuery to provide wrapper methods\n   * for data operations and data streaming.\n   */\n  constructor(\n    private readonly query: Query<T>,\n    private readonly afs: AngularFirestore) { }\n\n  /**\n   * Listen to the latest change in the stream. This method returns changes\n   * as they occur and they are not sorted by query order. This allows you to construct\n   * your own data structure.\n   */\n  stateChanges(events?: DocumentChangeType[]): Observable<DocumentChangeAction<T>[]> {\n    if (!events || events.length === 0) {\n      return docChanges<T>(this.query, this.afs.schedulers.outsideAngular).pipe(\n        this.afs.keepUnstableUntilFirst\n      );\n    }\n    return docChanges<T>(this.query, this.afs.schedulers.outsideAngular)\n      .pipe(\n        map(actions => actions.filter(change => events.indexOf(change.type) > -1)),\n        filter(changes =>  changes.length > 0),\n        this.afs.keepUnstableUntilFirst\n      );\n  }\n\n  /**\n   * Create a stream of changes as they occur it time. This method is similar to stateChanges()\n   * but it collects each event in an array over time.\n   */\n  auditTrail(events?: DocumentChangeType[]): Observable<DocumentChangeAction<T>[]> {\n    return this.stateChanges(events).pipe(scan((current, action) => [...current, ...action], []));\n  }\n\n  /**\n   * Create a stream of synchronized changes. This method keeps the local array in sorted\n   * query order.\n   */\n  snapshotChanges(events?: DocumentChangeType[]): Observable<DocumentChangeAction<T>[]> {\n    const validatedEvents = validateEventsArray(events);\n    const scheduledSortedChanges$ = sortedChanges<T>(this.query, validatedEvents, this.afs.schedulers.outsideAngular);\n    return scheduledSortedChanges$.pipe(\n      this.afs.keepUnstableUntilFirst\n    );\n  }\n\n  /**\n   * Listen to all documents in the collection and its possible query as an Observable.\n   *\n   * If the `idField` option is provided, document IDs are included and mapped to the\n   * provided `idField` property name.\n   */\n  valueChanges(): Observable<T[]>;\n  // tslint:disable-next-line:unified-signatures\n  valueChanges({}): Observable<T[]>;\n  valueChanges<K extends string>(options: {idField: K}): Observable<(T & { [T in K]: string })[]>;\n  valueChanges<K extends string>(options: {idField?: K} = {}): Observable<T[]> {\n    const fromCollectionRefScheduled$ = fromCollectionRef<T>(this.query, this.afs.schedulers.outsideAngular);\n    return fromCollectionRefScheduled$\n      .pipe(\n        map(actions => actions.payload.docs.map(a => {\n          if (options.idField) {\n            return {\n              [options.idField]: a.id,\n              ...a.data()\n            } as T & { [T in K]: string };\n          } else {\n            return a.data();\n          }\n        })),\n        this.afs.keepUnstableUntilFirst\n      );\n  }\n\n  /**\n   * Retrieve the results of the query once.\n   */\n  get(options?: firebase.firestore.GetOptions) {\n    return from(this.query.get(options)).pipe(\n      observeOn(this.afs.schedulers.insideAngular)\n    );\n  }\n\n}\n","import { Inject, Injectable, InjectionToken, NgZone, Optional, PLATFORM_ID } from '@angular/core';\nimport { from, Observable, of } from 'rxjs';\nimport {\n  AssociatedReference,\n  CollectionReference,\n  DocumentReference,\n  PersistenceSettings,\n  Query,\n  QueryFn,\n  QueryGroupFn,\n  Settings\n} from './interfaces';\nimport { AngularFirestoreDocument } from './document/document';\nimport { AngularFirestoreCollection } from './collection/collection';\nimport { AngularFirestoreCollectionGroup } from './collection-group/collection-group';\nimport {\n  FIREBASE_APP_NAME,\n  FIREBASE_OPTIONS,\n  FirebaseAppConfig,\n  FirebaseOptions,\n  ɵAngularFireSchedulers,\n  ɵfirebaseAppFactory,\n  ɵkeepUnstableUntilFirstFactory,\n  FirebaseApp\n} from '@angular/fire';\nimport { isPlatformServer } from '@angular/common';\nimport firebase from 'firebase/app';\nimport 'firebase/firestore';\nimport { USE_EMULATOR as USE_AUTH_EMULATOR } from '@angular/fire/auth';\nimport { ɵfetchInstance, ɵlogAuthEmulatorError } from '@angular/fire';\n\n/**\n * The value of this token determines whether or not the firestore will have persistance enabled\n */\nexport const ENABLE_PERSISTENCE = new InjectionToken<boolean>('angularfire2.enableFirestorePersistence');\nexport const PERSISTENCE_SETTINGS = new InjectionToken<PersistenceSettings | undefined>('angularfire2.firestore.persistenceSettings');\nexport const SETTINGS = new InjectionToken<Settings>('angularfire2.firestore.settings');\n\n// SEMVER(7): use Parameters to detirmine the useEmulator arguments\n// type UseEmulatorArguments = Parameters<typeof firebase.firestore.Firestore.prototype.useEmulator>;\ntype UseEmulatorArguments = [string, number];\nexport const USE_EMULATOR = new InjectionToken<UseEmulatorArguments>('angularfire2.firestore.use-emulator');\n\n/**\n * A utility methods for associating a collection reference with\n * a query.\n *\n * @param collectionRef - A collection reference to query\n * @param queryFn - The callback to create a query\n *\n * Example:\n * const { query, ref } = associateQuery(docRef.collection('items'), ref => {\n *  return ref.where('age', '<', 200);\n * });\n */\nexport function associateQuery<T>(collectionRef: CollectionReference<T>, queryFn = ref => ref): AssociatedReference<T> {\n  const query = queryFn(collectionRef);\n  const ref = collectionRef;\n  return { query, ref };\n}\n\ntype InstanceCache = Map<FirebaseApp, [\n  firebase.firestore.Firestore,\n  firebase.firestore.Settings | null,\n  UseEmulatorArguments | null,\n  boolean | null]\n>;\n\n/**\n * AngularFirestore Service\n *\n * This service is the main entry point for this feature module. It provides\n * an API for creating Collection and Reference services. These services can\n * then be used to do data updates and observable streams of the data.\n *\n * Example:\n *\n * import { Component } from '@angular/core';\n * import { AngularFirestore, AngularFirestoreCollection, AngularFirestoreDocument } from '@angular/fire/firestore';\n * import { Observable } from 'rxjs/Observable';\n * import { from } from 'rxjs/observable';\n *\n * @Component({\n *   selector: 'app-my-component',\n *   template: `\n *    <h2>Items for {{ (profile | async)?.name }}\n *    <ul>\n *       <li *ngFor=\"let item of items | async\">{{ item.name }}</li>\n *    </ul>\n *    <div class=\"control-input\">\n *       <input type=\"text\" #itemname />\n *       <button (click)=\"addItem(itemname.value)\">Add Item</button>\n *    </div>\n *   `\n * })\n * export class MyComponent implements OnInit {\n *\n *   // services for data operations and data streaming\n *   private readonly itemsRef: AngularFirestoreCollection<Item>;\n *   private readonly profileRef: AngularFirestoreDocument<Profile>;\n *\n *   // observables for template\n *   items: Observable<Item[]>;\n *   profile: Observable<Profile>;\n *\n *   // inject main service\n *   constructor(private readonly afs: AngularFirestore) {}\n *\n *   ngOnInit() {\n *     this.itemsRef = afs.collection('items', ref => ref.where('user', '==', 'davideast').limit(10));\n *     this.items = this.itemsRef.valueChanges().map(snap => snap.docs.map(data => doc.data()));\n *     // this.items = from(this.itemsRef); // you can also do this with no mapping\n *\n *     this.profileRef = afs.doc('users/davideast');\n *     this.profile = this.profileRef.valueChanges();\n *   }\n *\n *   addItem(name: string) {\n *     const user = 'davideast';\n *     this.itemsRef.add({ name, user });\n *   }\n * }\n */\n@Injectable({\n  providedIn: 'any'\n})\nexport class AngularFirestore {\n  public readonly firestore: firebase.firestore.Firestore;\n  public readonly persistenceEnabled$: Observable<boolean>;\n  public readonly schedulers: ɵAngularFireSchedulers;\n  public readonly keepUnstableUntilFirst: <T>(obs: Observable<T>) => Observable<T>;\n\n  /**\n   * Each Feature of AngularFire has a FirebaseApp injected. This way we\n   * don't rely on the main Firebase App instance and we can create named\n   * apps and use multiple apps.\n   */\n  constructor(\n    @Inject(FIREBASE_OPTIONS) options: FirebaseOptions,\n    @Optional() @Inject(FIREBASE_APP_NAME) nameOrConfig: string | FirebaseAppConfig | null | undefined,\n    @Optional() @Inject(ENABLE_PERSISTENCE) shouldEnablePersistence: boolean | null,\n    @Optional() @Inject(SETTINGS) settings: Settings | null,\n    // tslint:disable-next-line:ban-types\n    @Inject(PLATFORM_ID) platformId: Object,\n    zone: NgZone,\n    @Optional() @Inject(PERSISTENCE_SETTINGS) persistenceSettings: PersistenceSettings | null,\n    @Optional() @Inject(USE_EMULATOR) _useEmulator: any,\n    @Optional() @Inject(USE_AUTH_EMULATOR) useAuthEmulator: any,\n  ) {\n    this.schedulers = new ɵAngularFireSchedulers(zone);\n    this.keepUnstableUntilFirst = ɵkeepUnstableUntilFirstFactory(this.schedulers);\n\n    const app = ɵfirebaseAppFactory(options, zone, nameOrConfig);\n    if (!firebase.auth && useAuthEmulator) {\n      ɵlogAuthEmulatorError();\n    }\n    const useEmulator: UseEmulatorArguments | null = _useEmulator;\n\n    [this.firestore, this.persistenceEnabled$] = ɵfetchInstance(`${app.name}.firestore`, 'AngularFirestore', app, () => {\n      const firestore = zone.runOutsideAngular(() => app.firestore());\n      if (settings) {\n        firestore.settings(settings);\n      }\n      if (useEmulator) {\n        firestore.useEmulator(...useEmulator);\n      }\n\n      if (shouldEnablePersistence && !isPlatformServer(platformId)) {\n        // We need to try/catch here because not all enablePersistence() failures are caught\n        // https://github.com/firebase/firebase-js-sdk/issues/608\n        const enablePersistence = () => {\n          try {\n            return from(firestore.enablePersistence(persistenceSettings || undefined).then(() => true, () => false));\n          } catch (e) {\n            if (typeof console !== 'undefined') { console.warn(e); }\n            return of(false);\n          }\n        };\n        return [firestore, zone.runOutsideAngular(enablePersistence)];\n      } else {\n        return [firestore, of(false)];\n      }\n\n    }, [settings, useEmulator, shouldEnablePersistence]);\n  }\n\n  /**\n   * Create a reference to a Firestore Collection based on a path or\n   * CollectionReference and an optional query function to narrow the result\n   * set.\n   */\n  collection<T>(path: string, queryFn?: QueryFn): AngularFirestoreCollection<T>;\n  // tslint:disable-next-line:unified-signatures\n  collection<T>(ref: CollectionReference, queryFn?: QueryFn): AngularFirestoreCollection<T>;\n  collection<T>(pathOrRef: string | CollectionReference<T>, queryFn?: QueryFn): AngularFirestoreCollection<T> {\n    let collectionRef: CollectionReference<T>;\n    if (typeof pathOrRef === 'string') {\n      collectionRef = this.firestore.collection(pathOrRef) as firebase.firestore.CollectionReference<T>;\n    } else {\n      collectionRef = pathOrRef;\n    }\n    const { ref, query } = associateQuery<T>(collectionRef, queryFn);\n    const refInZone = this.schedulers.ngZone.run(() => ref);\n    return new AngularFirestoreCollection<T>(refInZone, query, this);\n  }\n\n  /**\n   * Create a reference to a Firestore Collection Group based on a collectionId\n   * and an optional query function to narrow the result\n   * set.\n   */\n  collectionGroup<T>(collectionId: string, queryGroupFn?: QueryGroupFn<T>): AngularFirestoreCollectionGroup<T> {\n    const queryFn = queryGroupFn || (ref => ref);\n    const collectionGroup: Query<T> = this.firestore.collectionGroup(collectionId) as firebase.firestore.Query<T>;\n    return new AngularFirestoreCollectionGroup<T>(queryFn(collectionGroup), this);\n  }\n\n  /**\n   * Create a reference to a Firestore Document based on a path or\n   * DocumentReference. Note that documents are not queryable because they are\n   * simply objects. However, documents have sub-collections that return a\n   * Collection reference and can be queried.\n   */\n  doc<T>(path: string): AngularFirestoreDocument<T>;\n  // tslint:disable-next-line:unified-signatures\n  doc<T>(ref: DocumentReference): AngularFirestoreDocument<T>;\n  doc<T>(pathOrRef: string | DocumentReference<T>): AngularFirestoreDocument<T> {\n    let ref: DocumentReference<T>;\n    if (typeof pathOrRef === 'string') {\n      ref = this.firestore.doc(pathOrRef) as firebase.firestore.DocumentReference<T>;\n    } else {\n      ref = pathOrRef;\n    }\n    const refInZone = this.schedulers.ngZone.run(() => ref);\n    return new AngularFirestoreDocument<T>(refInZone, this);\n  }\n\n  /**\n   * Returns a generated Firestore Document Id.\n   */\n  createId() {\n    return this.firestore.collection('_').doc().id;\n  }\n}\n","import { ModuleWithProviders, NgModule } from '@angular/core';\nimport { PersistenceSettings } from './interfaces';\nimport { AngularFirestore, ENABLE_PERSISTENCE, PERSISTENCE_SETTINGS } from './firestore';\n\n@NgModule({\n  providers: [ AngularFirestore ]\n})\nexport class AngularFirestoreModule {\n  /**\n   * Attempt to enable persistent storage, if possible\n   */\n  static enablePersistence(persistenceSettings?: PersistenceSettings): ModuleWithProviders<AngularFirestoreModule> {\n    return {\n      ngModule: AngularFirestoreModule,\n      providers: [\n        { provide: ENABLE_PERSISTENCE, useValue: true },\n        { provide: PERSISTENCE_SETTINGS, useValue: persistenceSettings },\n      ]\n    };\n  }\n}\n","import { Subscriber } from 'rxjs';\nimport firebase from 'firebase/app';\n\nexport type Settings =  firebase.firestore.Settings;\nexport type CollectionReference<T = DocumentData> = firebase.firestore.CollectionReference<T>;\nexport type DocumentReference<T = DocumentData> = firebase.firestore.DocumentReference<T>;\nexport type PersistenceSettings = firebase.firestore.PersistenceSettings;\nexport type DocumentChangeType = firebase.firestore.DocumentChangeType;\nexport type SnapshotOptions = firebase.firestore.SnapshotOptions;\nexport type FieldPath = firebase.firestore.FieldPath;\nexport type Query<T = DocumentData> = firebase.firestore.Query<T>;\n\nexport type SetOptions = firebase.firestore.SetOptions;\nexport type DocumentData = firebase.firestore.DocumentData;\n\nexport interface DocumentSnapshotExists<T> extends firebase.firestore.DocumentSnapshot {\n  readonly exists: true;\n  data(options?: SnapshotOptions): T;\n}\n\nexport interface DocumentSnapshotDoesNotExist extends firebase.firestore.DocumentSnapshot {\n  readonly exists: false;\n  data(options?: SnapshotOptions): undefined;\n  get(fieldPath: string | FieldPath, options?: SnapshotOptions): undefined;\n}\n\nexport type DocumentSnapshot<T> = DocumentSnapshotExists<T> | DocumentSnapshotDoesNotExist;\n\nexport interface QueryDocumentSnapshot<T> extends firebase.firestore.QueryDocumentSnapshot {\n  data(options?: SnapshotOptions): T;\n}\n\nexport interface QuerySnapshot<T> extends firebase.firestore.QuerySnapshot {\n  readonly docs: QueryDocumentSnapshot<T>[];\n}\n\nexport interface DocumentChange<T> extends firebase.firestore.DocumentChange {\n  readonly doc: QueryDocumentSnapshot<T>;\n}\n\nexport interface DocumentChangeAction<T> {\n  type: DocumentChangeType;\n  payload: DocumentChange<T>;\n}\n\nexport interface Action<T> {\n  type: string;\n  payload: T;\n}\n\nexport interface Reference<T> {\n  onSnapshot: (options: firebase.firestore.SnapshotListenOptions, sub: Subscriber<any>) => any;\n}\n\n// A convience type for making a query.\n// Example: const query = (ref) => ref.where('name', == 'david');\nexport type QueryFn<T = DocumentData> = (ref: CollectionReference<T>) => Query<T>;\n\nexport type QueryGroupFn<T = DocumentData> = (query: Query<T>) => Query<T>;\n\n/**\n * A structure that provides an association between a reference\n * and a query on that reference. Note: Performing operations\n * on the reference can lead to confusing results with complicated\n * queries.\n *\n * Example:\n *\n * const query = ref.where('type', '==', 'Book').\n *                  .where('price', '>' 18.00)\n *                  .where('price', '<' 100.00)\n *                  .where('category', '==', 'Fiction')\n *                  .where('publisher', '==', 'BigPublisher')\n *\n * // This addition would not be a result of the query above\n * ref.add({\n *  type: 'Magazine',\n *  price: 4.99,\n *  category: 'Sports',\n *  publisher: 'SportsPublisher'\n * });\n */\nexport interface AssociatedReference<T = DocumentData> {\n  ref: CollectionReference<T>;\n  query: Query<T>;\n}\n"]},"metadata":{},"sourceType":"module"}